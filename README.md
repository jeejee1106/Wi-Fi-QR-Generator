# Wi-Fi QR Generator

## 1. 프로젝트 개요

본 프로젝트는 Wi-Fi 연결 정보를 QR 코드로 제공하여, 사용자가 SSID 및 비밀번호를 직접 입력하지 않고도 네트워크에 연결할 수 있도록 돕는 백엔드 서비스입니다.

단순히 QR을 생성하는 기능 구현에 그치지 않고, **QR을 서버 제어의 진입점으로 설계하여** 실제 서비스 운영 시 발생할 수 있는 문제를 어떻게 통제할 것인가에 초점을 맞추었습니다.

특히 QR 만료, 비활성화, 권한 검증, 상태 전이와 같은 요소를 서버에서 관리할 수 있도록 설계함으로써, 한 번 배포된 QR이라도 정책 변경과 운영 제어가 가능한 구조를 목표로 했습니다.

이를 통해 보안, 권한, 상태 관리, 만료 처리 등 백엔드 서비스에서 핵심적으로 고려해야 할 설계 포인트를 중심으로 구현했습니다.

---

## 2. 문제 정의

* Wi-Fi 공유 시 SSID 및 비밀번호를 수동으로 입력해야 하는 UX 문제
* 비밀번호 평문 공유로 인한 보안 리스크
* QR 기반 공유 시 만료 및 사용 통제의 어려움
* 한 번 배포된 QR을 서버에서 제어하기 어려운 구조적 한계

---

## 3. 핵심 기능

* Wi-Fi 네트워크 등록
* 네트워크 기반 QR 코드 생성
* QR 코드 스캔 및 연결 API
* QR 코드 만료 및 비활성화 관리
* 회원 / 비회원 QR 생성 시나리오 분리
* 네트워크 소유자 기준 권한 검증

---

## 4. 기술 스택

* **Language**: Java 17
* **Framework**: Spring Boot, Spring Security
* **Database**: MySQL
* **Persistence**: MyBatis
* **Etc**: QR Code Generation, AES 기반 대칭키 암호화

---
## 5. 핵심 설계 & 트러블 슈팅

### 5.1 QR을 URL 기반으로 설계

본 프로젝트에서는 QR 코드에 Wi-Fi 연결 정보를 직접 포함하지 않고,  
**QR 식별자가 포함된 URL만을 담는 방식**으로 설계했습니다.

Wi-Fi 정보를 QR에 직접 포함할 경우 모바일 OS에서 즉시 연결이 가능하지만,  
다음과 같은 구조적 한계가 존재합니다.

- 서버에서 QR 만료 및 비활성화 제어 불가
- 한 번 배포된 QR 이미지 자체가 곧 연결 권한이 됨
- 운영 중 정책 변경 및 접근 통제가 어려움

이를 해결하기 위해 QR Content에는 다음과 같은 URL만 포함합니다.

```
/qr/connect/{qrCodeSeq}
```

QR을 스캔하면 서버로 요청이 전달되고, 서버는 다음 절차를 수행합니다.

1. QR 존재 여부 확인
2. 활성 상태 확인
3. 만료 여부 판단
4. 유효한 경우에만 Wi-Fi 연결 정보 생성 및 응답

이 구조를 통해:

* QR 만료 및 비활성화 정책을 서버에서 통제 가능
* QR 이미지 자체에는 민감 정보 미포함
* 실시간 정책 변경 및 확장 가능한 구조 확보

QR을 단순한 출력물이 아니라, **서버가 통제 가능한 접근 진입점**으로 다룰 수 있도록 설계했습니다.

---

### 5.2 QR 스캔 API 응답 모델링에 대한 설계 판단

QR 스캔 API는 다음과 같이 다양한 실패 원인을 가질 수 있습니다.

- QR이 존재하지 않는 경우
- 이미 비활성화된 QR
- 만료된 QR
- 권한이 없는 접근

#### 설계 고민

- 실패 사유를 세분화할 경우, 내부 상태가 과도하게 노출되지 않는가?
- 모든 실패를 동일 응답으로 처리하면 클라이언트 분기 처리가 어려워지지 않는가?
- 이 API의 주 사용자는 “사람”이 아니라 “QR 스캔 플로우”라는 점을 어떻게 반영할 것인가?

#### 선택한 설계 방향

본 프로젝트에서는 QR 스캔 API를 **연결 가능 여부 판단을 위한 진입 API**로 정의했습니다.

- 클라이언트가 반드시 알아야 하는 최소한의 정보만 응답
- 존재 여부, 권한, 만료 사유 등의 내부 상태는 서버 로그에서만 관리
- API 응답 스펙은 단순하고 안정적으로 유지

#### 결과

- API 응답 구조의 단순화
- 내부 정책 변경 시 클라이언트 영향 최소화
- QR 스캔 플로우의 일관성 확보

---

### 5.3 QR 만료 처리 책임 분리 설계

QR 스캔 API는 **조회(Read) 성격의 API**로 정의하고,  
“연결 가능 여부 판단”까지만 수행하도록 설계했습니다.

만료 여부는 판단하되,  
상태 변경(`active_yn` 업데이트)은 스캔 API의 책임이 아니라고 판단했습니다.

#### 설계 의도

- 조회 요청이 데이터 상태를 변경하지 않도록 책임 분리
- 읽기 트래픽 증가 시 불필요한 DB write 방지
- 트랜잭션 경계 명확화

이에 따라 실제 비활성화 처리는  
별도의 관리 API 또는 배치/스케줄러로 분리 가능한 구조로 설계했습니다.

#### 트러블 슈팅 – QR 만료 처리를 조회 시점에 반영할 것인가

**문제 상황**  
초기 구현에서는 QR 스캔 시 만료된 경우  
즉시 `active_yn = 'N'` 으로 업데이트하도록 처리했습니다.

이로 인해 동일한 만료 QR에 대한 조회 요청이 반복될 경우,  
조회 트래픽임에도 지속적인 DB write가 발생하는 문제가 있었습니다.

**고민 지점**
- 조회 API에서 데이터 상태를 변경하는 것이 적절한가?
- 만료 판단과 상태 변경 책임을 어디까지 가져가야 하는가?

**해결 방법**
- QR 조회 API에서는 만료 여부 판단까지만 수행
- 상태 변경은 별도의 책임(관리 API 또는 배치)으로 분리
- 조회 트래픽 증가 시에도 write가 발생하지 않도록 개선

**결과**
- 조회 API의 역할과 책임이 명확해짐
- 읽기/쓰기 트래픽 성격 분리
- 트랜잭션 복잡도 감소

---

### 5.4 QR 비활성화 API의 Idempotency 보장 설계

QR 및 네트워크 비활성화 API는  
네트워크 오류나 재시도로 인해 **중복 호출될 수 있음을 전제로 설계**했습니다.

이미 비활성화된 리소스에 대해서도  
동일한 응답을 반환하며,  
상태 변경은 최초 요청에서만 발생하도록 구성했습니다.

#### 설계 의도

- 재시도에 안전한 API 제공
- 클라이언트 구현 단순화
- 삭제/비활성화 시점 정보의 의미 보존

#### 트러블 슈팅 – 네트워크 삭제 API 멱등성 미보장 이슈

**문제 상황**  
`wifi_network`, `wifi_qr_code` 테이블의 `updated_at` 컬럼은  
`ON UPDATE CURRENT_TIMESTAMP` 설정을 사용하고 있었습니다.

네트워크 삭제 API가 반복 호출될 경우,

- 네트워크 테이블은 이미 비활성 상태라 추가 변경이 없었지만
- QR 테이블은 `deactivated_at = NOW()` 로 인해  
  매 요청마다 업데이트가 발생하며 `updated_at`이 계속 변경되었습니다.

**고민 지점**
- 동일한 삭제 요청에 대해 연관 테이블의 상태 변경 시각이 달라지는 것이 적절한가?
- 이미 삭제된 리소스에 대한 재요청에서도 write가 발생하는 구조가 맞는가?
- 삭제 API는 어느 수준까지 멱등성을 보장해야 하는가?

**해결 방법**
- QR 비활성화 UPDATE 쿼리에  
  `active_yn = 'Y' AND deactivated_at IS NULL` 조건 추가
- 최초 삭제 시에만 상태 변경이 발생하도록 쿼리 개선

**결과**
- 삭제 API의 멱등성 보장
- 불필요한 DB write 및 timestamp 변경 방지
- 최초 비활성화 시점 정보의 의미 보존

---

## 6. 운영 관점에서의 한계 및 개선 방향

본 프로젝트는 개인 프로젝트로 실제 운영 환경은 아니며, 이에 따라 실 트래픽 기반의 성능 검증이나 운영 자동화까지는 구현하지 않았습니다.  
다만, 향후 운영 환경으로 확장될 가능성을 고려하여 아래와 같은 방향을 설계 단계에서 검토했습니다.

### 운영 관점에서의 한계
* 실제 트래픽 환경에서의 성능 검증 미흡
* 테스트 코드 커버리지 부족
* 모니터링 및 장애 대응 시스템 미구현

### 설계 단계에서 고려한 확장 방향
* QR 조회 트래픽 증가 시 Redis 캐싱 적용 가능
* QR 만료 처리 배치 또는 스케줄러 분리 가능
* Idempotent API 설계로 재시도 안전성 확보
* 로그 레벨 분리 및 감사 로그 확장 가능

> 현재는 설계 및 문서화 수준으로만 고려되어 있으며, 실제 구현은 프로젝트 범위를 벗어나 제외했습니다.

### 향후 개선 계획
* Service 단위 테스트 및 핵심 비즈니스 로직 테스트 추가
* Redis 기반 캐싱 및 QR 만료 전략 적용
* Docker 기반 실행 환경 구성 및 배포 환경 표준화

---

## 7. 프로젝트를 통해 얻은 점

* 단순 CRUD 구현을 넘어 **상태 전이와 책임 분리의 중요성**에 대한 이해
* 조회/쓰기 API 역할을 명확히 나누는 설계 경험
* 실제 운영 환경을 가정하고, 재시도·중복 요청·만료 처리와 같은 리스크를 사전에 고려하는 설계 습관

### Map 기반 설계에서 벗어난 경험

이전 회사에서는 요청/응답 및 내부 로직에서 `Map<String, Object>`를 광범위하게 사용하는 구조를 경험했습니다.  
빠른 개발에는 유리했지만, 다음과 같은 한계가 있었습니다.

* 컴파일 시점에 파라미터 구조와 타입이 보장되지 않음
* 키 오타나 값 타입 변경이 런타임 오류로 이어질 가능성
* 도메인 개념이 코드에 드러나지 않아 로직 파악과 유지보수가 어려움

본 프로젝트에서는 이러한 경험을 바탕으로, Map 사용을 의도적으로 배제하고 다음 원칙을 적용했습니다.

* 요청/응답 및 내부 로직에서 명시적인 DTO와 파라미터 객체 사용
* 필수 값은 Bean Validation을 통해 요청 단계에서 검증
* 서비스 로직에서는 검증된 데이터를 전제로 비즈니스 로직에 집중
* 도메인 간 관계와 책임을 타입과 메서드 시그니처로 명확히 표현

**그 결과**

* 요청 구조와 필수 값이 코드에 명확히 드러나 가독성 향상
* 컴파일 단계 및 요청 진입 단계에서 오류를 조기에 차단 가능
* 메서드 시그니처만으로도 비즈니스 의미 파악 가능
* 코드 리뷰 및 유지보수 시 이해 비용 감소

이 경험을 통해, 단기적인 개발 속도보다 **장기적인 안정성과 가독성을 고려한 설계의 중요성**을 체감했습니다.

---

> 기능 구현보다 **상태 관리와 운영 리스크를 어떻게 제어할지에 집중한 백엔드 프로젝트**입니다.
