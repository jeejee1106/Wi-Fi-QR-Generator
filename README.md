# Wi-Fi QR Generator

## 1. 프로젝트 개요

본 프로젝트는 Wi-Fi 연결 정보를 QR 코드로 제공하여, 사용자가 SSID 및 비밀번호를 직접 입력하지 않고도 네트워크에 연결할 수 있도록 돕는 백엔드 서비스입니다.

단순히 QR을 생성하는 기능 구현에 그치지 않고, **QR을 서버 제어의 진입점으로 설계하여** 실제 서비스 운영 시 발생할 수 있는 문제를 어떻게 통제할 것인가에 초점을 맞추었습니다.

특히 QR 만료, 비활성화, 권한 검증, 상태 전이와 같은 요소를 서버에서 관리할 수 있도록 설계함으로써, 한 번 배포된 QR이라도 정책 변경과 운영 제어가 가능한 구조를 목표로 했습니다.

이를 통해 보안, 권한, 상태 관리, 만료 처리 등 백엔드 서비스에서 핵심적으로 고려해야 할 설계 포인트를 중심으로 구현했습니다.

---

## 2. 문제 정의

* Wi-Fi 공유 시 SSID 및 비밀번호를 수동으로 입력해야 하는 UX 문제
* 비밀번호 평문 공유로 인한 보안 리스크
* QR 기반 공유 시 만료 및 사용 통제의 어려움
* 한 번 배포된 QR을 서버에서 제어하기 어려운 구조적 한계

---

## 3. 핵심 기능

* Wi-Fi 네트워크 등록
* 네트워크 기반 QR 코드 생성
* QR 코드 스캔 및 연결 API
* QR 코드 만료 및 비활성화 관리
* 회원 / 비회원 QR 생성 시나리오 분리
* 네트워크 소유자 기준 권한 검증

---

## 4. 기술 스택

* **Language**: Java 17
* **Framework**: Spring Boot, Spring Security
* **Database**: MySQL
* **Persistence**: MyBatis
* **Etc**: QR Code Generation, AES 기반 대칭키 암호화

---
## 5. 핵심 설계와 주요 설계 결정

### 5.1 QR을 URL 기반으로 설계
#### `설계 배경`
본 프로젝트에서는 QR 코드 기반으로 Wi-Fi 연결을 제공해야 했으며,  
QR을 어떤 형태의 정보로 구성할 것인지가 핵심 설계 포인트였습니다.

#### `문제 인식`
Wi-Fi 연결 정보를 QR에 직접 포함할 경우,  
모바일 OS에서 즉시 연결이 가능하다는 장점은 있으나 다음과 같은 구조적 한계가 존재했습니다.

- 서버에서 QR 만료 및 비활성화 제어 불가
- 한 번 배포된 QR 이미지 자체가 곧 연결 권한이 됨
- 운영 중 정책 변경 및 접근 통제가 어려움

#### `설계 결정`
QR을 단순한 연결 수단이 아닌, **서버가 통제 가능한 접근 진입점**으로 다루기 위해  
QR에는 Wi-Fi 정보가 아닌 **QR 식별자가 포함된 URL만을 담는 방식**을 선택했습니다.  
QR Content는 다음과 같이 구성됩니다.
```
https://domain/qr/url/{qrCodeSeq}
```

#### `구조 및 동작`
QR 스캔 시 서버는 다음 절차를 수행합니다.

1. QR 존재 여부 확인
2. 활성 상태 확인
3. 만료 여부 판단
4. 유효한 경우에만 Wi-Fi 연결 정보 생성 및 응답

#### `설계 효과`
* QR 만료 및 비활성화 정책을 서버에서 통제 가능
* QR 이미지 자체에는 민감 정보 미포함
* 실시간 정책 변경 및 확장 가능한 구조 확보

---

### 5.2 QR 스캔 API 실패응답 모델링에 대한 설계
#### `설계 배경`
QR 스캔 API는 QR 코드 기반 연결 흐름에서
QR의 상태를 확인하고, 연결 가능 여부를 클라이언트에 전달하는 역할을 합니다.

이 과정에서 QR 상태에 따라 다양한 실패 상황이 발생할 수 있으며,
각 실패를 어떤 수준까지 구분하여 응답할 것인지에 대한 설계 판단이 필요했습니다.

#### `문제 인식`
QR 스캔 과정에서는 다음과 같이 다양한 실패 상황이 발생할 수 있습니다.

- 존재하지 않는 QR
- 이미 비활성화된 QR
- 만료된 QR

이 모든 상황을 응답 코드나 메시지로 세분화할 경우,

- 서버 내부 상태가 과도하게 노출될 수 있고
- 정책 변경 시 클라이언트 수정 범위가 커질 수 있으며
- QR 스캔 플로우가 불필요하게 복잡해질 수 있다고 판단했습니다.

#### `설계 결정`
본 프로젝트에서는 QR 스캔 API의 응답을
**클라이언트가 다음 동작을 결정하는 데 필요한 최소 정보만 전달하는 방향**으로 설계했습니다.

- 실패 사유를 과도하게 세분화하지 않음
- 내부 상태(존재 여부, 만료 원인, 권한 판단 기준 등)는 서버 로그에서만 관리
- 응답 스펙은 단순하고 안정적으로 유지

#### `설계 효과`
- API 응답 구조의 단순화
- 내부 정책 변경 시 클라이언트 영향 최소화
- QR 스캔 플로우의 일관성 확보

---

### 5.3 QR 만료 처리 책임 분리 설계
#### `설계 배경`
QR 스캔 API는 QR 기반 연결 플로우의 진입점으로,  
빈번한 호출이 발생할 수 있는 조회(Read) 성격의 API입니다.

이에 따라 해당 API가 어디까지 책임을 가져야 하는지에 대한  
명확한 설계 기준이 필요했습니다.

#### `문제 인식`
초기 설계에서는 QR 스캔 시 만료 여부를 판단하면서,  
만료된 경우 즉시 `active_yn = 'N'` 으로 상태를 변경하도록 구현했습니다.

이 구조에서는 동일한 만료 QR에 대한 스캔 요청이 반복될 경우,  
조회 트래픽임에도 불구하고 지속적인 DB write가 발생하는 문제가 있었습니다.

#### `설계 결정`
QR 스캔 API를 **연결 가능 여부 판단을 위한 조회 API**로 정의하고,

- 만료 여부는 판단하되
- 상태 변경(`active_yn` 업데이트)은 스캔 API의 책임이 아니라고 판단했습니다.

상태 변경 책임은 별도의 관리 API 또는 배치/스케줄러로 분리 가능한 구조를 선택했습니다.

#### `구조 및 동작`
- QR 스캔 API에서는 만료 여부 판단까지만 수행
- 상태 변경은 관리 API 또는 배치 처리로 위임
- 조회 API 호출 시 데이터 상태 변경이 발생하지 않도록 설계

#### `설계 효과`
- 조회 API의 역할과 책임이 명확해짐
- 읽기/쓰기 트래픽 성격 분리
- 트랜잭션 복잡도 감소

---

### 5.4 QR 비활성화 API의 Idempotency 보장 설계
#### `설계 배경`
QR 및 네트워크 비활성화 API는 네트워크 오류나 클라이언트의 의도적인 재시도로 인해 중복 호출될 수 있는 API입니다.
따라서 동일 요청이 여러 번 호출되더라도 상태가 불필요하게 변경되지 않도록 설계할 필요가 있었습니다.

#### `문제 인식`
**wifi_network**, **wifi_qr_code** 테이블의 **updated_at** 컬럼은  
`ON UPDATE CURRENT_TIMESTAMP` 설정을 사용하고 있었습니다.

네트워크 삭제 API가 반복 호출될 경우,

- 네트워크 테이블은 이미 비활성 상태라 추가 변경이 없었지만
- QR 테이블은 `deactivated_at = NOW()` 로 인해  
  매 요청마다 업데이트가 발생하며 **updated_at** 컬럼이 계속 변경되는 문제가 있었습니다.

#### `설계 결정`
삭제/비활성화 API는 **멱등성을 보장해야 하는 API**로 정의하고,

- 이미 비활성화된 리소스에 대해서는
- 동일한 응답을 반환하되 상태 변경은 최초 요청에서만 발생하도록 설계했습니다.

#### `구조 및 동작`
- QR 비활성화 UPDATE 쿼리에 `active_yn = 'Y' AND deactivated_at IS NULL` 조건 추가
- 최초 비활성화 요청에서만 상태 변경 발생
- 이후 동일 요청에 대해서는 write 없이 동일 응답 반환

#### `설계 효과`
- 삭제 API의 멱등성 보장
- 불필요한 DB write 및 timestamp 변경 방지
- 최초 비활성화 시점 정보의 의미 보존

---

## 6. 프로젝트를 통해 얻은 점
* 단순 CRUD 구현을 넘어 **상태 전이와 책임 분리의 중요성**에 대한 이해
* 조회/쓰기 API 역할을 명확히 나누는 설계 경험
* 실제 운영 환경을 가정하고, 재시도·중복 요청·만료 처리와 같은 리스크를 사전에 고려하는 설계 습관

### Map 기반 설계에서 벗어난 경험

이전 회사에서는 요청/응답 및 내부 로직에서 `Map<String, Object>`를 광범위하게 사용하는 구조를 경험했습니다.  
빠른 개발에는 유리했지만, 다음과 같은 한계가 있었습니다.

* 컴파일 시점에 파라미터 구조와 타입이 보장되지 않음
* 키 오타나 값 타입 변경이 런타임 오류로 이어질 가능성
* 도메인 개념이 코드에 드러나지 않아 로직 파악과 유지보수가 어려움

본 프로젝트에서는 이러한 경험을 바탕으로, Map 사용을 의도적으로 배제하고 다음 원칙을 적용했습니다.

* 요청/응답 및 내부 로직에서 명시적인 DTO와 파라미터 객체 사용
* 필수 값은 Bean Validation을 통해 요청 단계에서 검증
* 서비스 로직에서는 검증된 데이터를 전제로 비즈니스 로직에 집중
* 도메인 간 관계와 책임을 타입과 메서드 시그니처로 명확히 표현

**그 결과**

* 요청 구조와 필수 값이 코드에 명확히 드러나 가독성 향상
* 컴파일 단계 및 요청 진입 단계에서 오류를 조기에 차단 가능
* 메서드 시그니처만으로도 비즈니스 의미 파악 가능
* 코드 리뷰 및 유지보수 시 이해 비용 감소

이 경험을 통해, 단기적인 개발 속도보다 **장기적인 안정성과 가독성을 고려한 설계의 중요성**을 체감했습니다.

---

> 본 프로젝트는 개인 프로젝트로, 실 운영 환경을 가정한 자동화나 모니터링까지는 구현하지 않았으며,
> 기능 구현보단 **상태 관리와 운영 리스크를 어떻게 제어할지에 집중한 백엔드 프로젝트**입니다.
